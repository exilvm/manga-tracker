/* eslint-disable react-hooks/rules-of-hooks */
import * as React from 'react';
import {IconButton, Input,} from '@material-ui/core';
import {
  Cancel as CancelIcon,
  Edit as EditIcon,
  Save as SaveIcon,
} from '@material-ui/icons';
import {actions, defaultColumn,} from 'react-table';

actions.startEditingRow = 'startEditingRow';
actions.stopEditingRow = 'stopEditingRow';

function prepareRow(row, { instance }) {
  row.startEditingRow = () => instance.startEditingRow(row.id);
  row.stopEditingRow = () => instance.stopEditingRow(row.id);
}

function isRowBeingEdited(row, rowEditStates) {
  return Boolean(rowEditStates[row.id]);
}

/**
 * Simple function that sets the row edit state after a cell has been edited
 * @param newValue The new value for that cell
 * @param rowState current rowEditStates
 * @param cell current cell that was edited
 */
export function processCellEdit(newValue, rowState, cell) {
  rowState[cell.row.id][cell.column.id] = newValue;
}

/**
 * Default implementation of the row save action.
 * Will update current row values to the edited ones.
 * @param row The row generated by react table
 * @param state Current state of react table
 */
function defaultOnSaveRow(row, state) {
  Object.keys(state).forEach(key => {
    row.values[key] = state[key];
  });
}

function reducer(state, action) {
  if (action.type === actions.init) {
    return {
      rowEditStates: {},
      ...state,
    };
  }

  // Start editing row
  if (action.type === actions.startEditingRow) {
    const { id } = action;

    if (state.rowEditStates[id]) {
      return state;
    }

    const newRowEditStates = { ...state.rowEditStates };
    newRowEditStates[id] = {};

    return {
      ...state,
      rowEditStates: newRowEditStates,
    };
  }

  // Stop editing row
  if (action.type === actions.stopEditingRow) {
    const { id } = action;

    if (!state.rowEditStates[id]) {
      return state;
    }

    const newRowEditStates = { ...state.rowEditStates };
    newRowEditStates[id] = false;

    return {
      ...state,
      rowEditStates: newRowEditStates,
    };
  }
}

function useInstance(instance) {
  const {
    rows,
    flatHeaders,
    state: { rowEditStates },
    dispatch,
    disableEditing,
  } = instance;

  // Add properties to rows
  const editingFlatRows = React.useMemo(() => {
    const editingFlatRowsInner = [];

    rows.forEach(row => {
      row.beingEdited = isRowBeingEdited(row, rowEditStates);

      if (row.beingEdited) {
        editingFlatRowsInner.push(row);
      }
    });

    return editingFlatRowsInner;
  }, [rows, rowEditStates]);

  // Add properties to columns
  const editableColumns = React.useMemo(() => {
    const editableColumnsInner = [];

    flatHeaders.forEach(col => {
      // eslint-disable-next-line no-nested-ternary
      if (disableEditing) {
        col.canEdit = false;
      } else {
        col.canEdit = col.canEdit === undefined ? true : col.canEdit;
      }

      if (col.canEdit) {
        editableColumnsInner.push(col);
      }
    });

    return editableColumnsInner;
  }, [flatHeaders, disableEditing]);

  // Start row edit dispatch
  const startEditingRow = React.useCallback(
    (id) => dispatch({ type: actions.startEditingRow, id }),
    [dispatch],
  );

  // Stop row edit dispatch
  const stopEditingRow = React.useCallback(
    (id) => dispatch({ type: actions.stopEditingRow, id }),
    [dispatch],
  );

  Object.assign(instance, {
    editingFlatRows,
    startEditingRow,
    stopEditingRow,
    editableColumns,
  });
}

function DefaultEditCell({ value, cell, state }) {
  return (
    <Input
      defaultValue={value}
      onChange={(event => processCellEdit(event.currentTarget.value, state.rowEditStates, cell))}
    />
  );
}

function visibleColumns(columns, { instance }) {
  const {
    onSaveRow = defaultOnSaveRow,
    onCancelRow = () => {},
    onEditRow = () => {},
    classes,
    disableEditing,
  } = instance;

  if (disableEditing) return columns;

  const onStartEdit = row => {
    row.startEditingRow();
    onEditRow(row);
  };

  const onStopEdit = (cancel, row, state, inst) => {
    row.stopEditingRow();
    cancel ?
      onCancelRow(row, state, inst) :
      onSaveRow(row, state, inst);
  };

  return [
    {
      id: 'edit',
      padding: 'checkbox',
      Header: () => null,
      show: !disableEditing,
      // eslint-disable-next-line react/display-name
      Cell: (inst) => {
        const { row, state } = inst;
        return (
          <div className={classes.editCell}>
            {!row.beingEdited ? (
              <IconButton onClick={() => onStartEdit(row)}>
                <EditIcon />
              </IconButton>
            ) : (
              <>
                <IconButton onClick={() => onStopEdit(false, row, state.rowEditStates[row.id], inst)}>
                  <SaveIcon />
                </IconButton>
                <IconButton onClick={() => onStopEdit(true, row, state.rowEditStates[row.id], inst)}>
                  <CancelIcon />
                </IconButton>
              </>
            )}
          </div>
        );
      },
    },
  ...columns.map(col => ({
    OriginalCell: col.Cell || defaultColumn.Cell,
    EditCell: col.EditCell || DefaultEditCell,
    ...col,
    Cell: ({ row, cell }) => (
      (cell.column.canEdit && row.beingEdited) ?
        cell.render('EditCell') :
        cell.render('OriginalCell')
    ),
    })),
  ];
}

/**
 * Parameters accepted by this plugin
 * - onSaveRow: Function called when row is saved. Defaults to `defaultOnSaveRow`
 * - onCancelRow: Function called when row edit was cancelled
 * - onEditRow: Function called when row editing begins
 * - classes.editCell: Class name for edit cell content
 * - disableEditing: boolean that determines whether editing is enabled or not
 */
export const useEditable = hooks => {
  hooks.visibleColumns.push(visibleColumns);
  hooks.stateReducers.push(reducer);
  hooks.useInstance.push(useInstance);
  hooks.prepareRow.push(prepareRow);
};
